# 资源管理

在编程中，你将面临的一个常见问题是如何正确管理外部资源，如文件、锁和网络连接。有时，一个程序会永远保留这些资源，即使你不再需要它们了。这种问题被称为内存泄漏，因为每次你在没有关闭现有资源的情况下创建和打开一个新的实例时，可用的内存就会减少。

正确管理资源往往是一个棘手的问题。它需要一个设置阶段和一个解除阶段。后一阶段需要你执行一些清理动作，如关闭文件、释放锁、或关闭网络连接。如果你忘记执行这些清理动作，那么你的应用程序就会保持资源的活力。这可能会损害宝贵的系统资源，如内存和网络带宽。

例如，当开发者与数据库打交道时，可能出现的一个常见问题是，程序不断创建新的连接而不释放或重新使用这些连接。在这种情况下，数据库后端可以停止接受新的连接。这可能需要管理员登录并手动杀死这些陈旧的连接，以使数据库再次可用。

另一个经常出现的问题是当开发人员在处理文件时。向文件写入文本通常是一个缓冲操作。这意味着在一个文件上调用.write()不会立即导致将文本写入物理文件，而是写入一个临时缓冲区。有时，当缓冲区没有满，而开发人员忘记调用.close()
，部分数据就会永远丢失。

```python

file = open("hello.txt", "w")
file.write("Hello, World!")
file.close()
```

在 Python 中，你可以使用两种通用的方法来处理资源管理问题。你可以将你的代码包裹在:

1. A try … finally construct
2. A with construct

- 第一种方法是相当普遍的，允许你提供设置和拆除代码来管理任何种类的资源。然而，它有点啰嗦。另外，如果你忘记了任何清理动作怎么办？

- 第二种方法提供了一种直接的方法来提供和重用设置和拆除的代码。在这种情况下，你会有一个限制，即 with 语句只适用于上下文管理器。在接下来的两节中，你将学习如何在你的代码中使用这两种方法。

## 使用 with 语句

Python with 语句创建了一个运行时上下文，允许你在上下文管理器的控制下运行一组语句。PEP 343 添加了 with 语句，使 try ... finally 语句的标准用例成为可能。

与传统的 try ... finally 结构相比，with 语句可以使你的代码更清晰、更安全、更可重用。标准库中的许多类都支持 with 语句。一个典型的例子是 open()，它允许你用 with 来处理文件对象。

要写一个 with 语句，你需要使用以下的一般语法。

```python
with expression as target_var:
    do_something(target_var)
```

上下文管理对象是对与之后的表达式进行评估的结果。换句话说，表达式必须返回一个实现上下文管理协议的对象。这个协议由两个特殊的方法组成。

- `.__enter__()`被 with 语句调用，以进入运行时上下文。
- `.__exit__()`在执行离开 with 代码块时被调用。

as 指定符是可选的。如果你在 as 中提供了一个 target_var，那么在上下文管理对象上调用 .`__enter__()` 的返回值将被绑定到该变量上。

> 注意: 一些上下文管理器从 .`__enter__()` 返回 None，因为它们没有有用的对象可以返回给调用者。在这些情况下，指定一个 target_var 是没有意义的。

下面是当 Python 遇到 with 语句时，它是如何进行的。

- 调用表达式以获得一个上下文管理器。
- 存储上下文管理器的 .`__enter__()` 和 .`_exit__()` 方法供以后使用。
- 在上下文管理器上调用 .`__enter__()` 并将其返回值绑定到 target_var (如果提供的话)。
- 执行 with 代码块。
- 当与代码块执行完毕时，在上下文管理器上调用 .`_exit__()` 。

在这种情况下，.`__enter__()`，通常提供设置代码。with 语句是一个复合语句，开始一个代码块，像一个条件语句或一个 for
循环。在这个代码块中，你可以运行几个语句。通常情况下，如果适用的话，你使用 with 代码块来操作 target_var。

一旦 with 代码块完成，.`_exit__()` 就会被调用。这个方法通常提供拆解逻辑或清理代码，例如在一个打开的文件对象上调用 .close() 。这就是为什么 with 语句是如此有用。它使正确获取和释放资源变得轻而易举。

# 在 python 中使用 with

## 使用 with 打开文件

```python3
with open("hello.txt", mode="w") as file:
    file.write("Hello, World!")
```

当你运行这个 with 语句时，open() 返回一个 io.TextIOBase 对象。这个对象也是一个上下文管理器，所以 with 语句调用 .`__enter__()` 并将其返回值分配给 file。然后你可以在 with
代码块中操作该文件。当代码块结束时，.`_exit__()` 会自动被调用，并为你关闭文件，即使在 with 代码块中引发了一个异常。

这个 with 结构比它的 try ... finally 更短，但它也不太通用，正如你已经看到的。你只能对支持上下文管理协议的对象使用 with 语句，而 try ... finally 允许你对任意对象执行清理操作，而不需要支持上下文管理协议。

## 遍历文件夹

os 模块提供了一个叫做 scandir()的函数，它返回一个对应于给定目录中条目的 os.DirEntry 对象的迭代器。这个函数是专门设计的，以便在你遍历一个目录结构时提供最佳性能。

用给定目录的路径作为参数调用 scandir()，会返回一个支持上下文管理协议的迭代器。

```python
import os

with os.scandir(".") as entries:
    for entry in entries:
        print(entry.name, "->", entry.stat().st_size, "bytes")
```

## 在多线程程序中处理锁

在 Python 标准库中有效使用 with 语句的另一个好例子是 threading.Lock。这个类提供了一个原始的锁，以防止多个线程在多线程程序中同时修改一个共享资源。

你可以在 with 语句中使用一个 Lock 对象作为上下文管理器来自动获取和释放一个给定的锁。例如，假设你需要保护一个银行账户的余额。

```python
import threading

balance_lock = threading.Lock()

# Use the try ... finally pattern
balance_lock.acquire()
try:
# Update the account balance here ...
finally:
    balance_lock.release()

# Use the with pattern
with balance_lock:
# Update the account balance here ...
```

第二个例子中的 with 语句在执行流进入和离开该语句时自动获取和释放一个锁。这样，你就可以专注于你的代码中真正重要的部分，而忘记那些重复的操作。

在这个例子中，with 语句中的锁创建了一个被称为 "关键部分 "的受保护区域，它阻止了对账户余额的并发访问。

# 总结 with 语句的优点

为了总结你到目前为止所学到的知识，下面是在你的代码中使用 Python with 语句的一些好处。

- 使得资源管理比其对应的 try ... finally 语句更安全
- 封装了上下文管理中 try ... finally 语句的标准用法
- 允许重复使用自动管理特定操作的设置和拆除阶段的代码
- 有助于避免资源泄漏
- 坚持使用 with 语句可以提高你的代码的总体质量，并通过防止资源泄漏问题使其更加安全。
