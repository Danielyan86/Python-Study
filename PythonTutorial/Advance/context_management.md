# 资源管理
在编程中，你将面临的一个常见问题是如何正确管理外部资源，如文件、锁和网络连接。有时，一个程序会永远保留这些资源，即使你不再需要它们了。这种问题被称为内存泄漏，因为每次你在没有关闭现有资源的情况下创建和打开一个新的实例时，可用的内存就会减少。

正确管理资源往往是一个棘手的问题。它需要一个设置阶段和一个拆解阶段。后一阶段需要你执行一些清理动作，如关闭文件、释放锁、或关闭网络连接。如果你忘记执行这些清理动作，那么你的应用程序就会保持资源的活力。这可能会损害宝贵的系统资源，如内存和网络带宽。

例如，当开发者与数据库打交道时，可能出现的一个常见问题是，程序不断创建新的连接而不释放或重新使用这些连接。在这种情况下，数据库后端可以停止接受新的连接。这可能需要管理员登录并手动杀死这些陈旧的连接，以使数据库再次可用。

另一个经常出现的问题是当开发人员在处理文件时。向文件写入文本通常是一个缓冲操作。这意味着在一个文件上调用.write()不会立即导致将文本写入物理文件，而是写入一个临时缓冲区。有时，当缓冲区没有满，而开发人员忘记调用.close()，部分数据就会永远丢失。


```python

file = open("hello.txt", "w")
file.write("Hello, World!")
file.close()
```

在Python中，你可以使用两种通用的方法来处理资源管理问题。你可以将你的代码包裹在:

```
A try … finally construct
A with construct
```
# with 语句的方法
Python with 语句创建了一个运行时上下文，允许你在上下文管理器的控制下运行一组语句。PEP 343 添加了 with 语句，使 try ... finally 语句的标准用例成为可能。

与传统的try ... finally结构相比，with语句可以使你的代码更清晰、更安全、更可重用。标准库中的许多类都支持with语句。一个典型的例子是open()，它允许你用with来处理文件对象。

要写一个with语句，你需要使用以下的一般语法。

```python
with expression as target_var:
    do_something(target_var)
```

上下文管理对象是对与之后的表达式进行评估的结果。换句话说，表达式必须返回一个实现上下文管理协议的对象。这个协议由两个特殊的方法组成。

.__enter__()被with语句调用，以进入运行时上下文。
.__exit__()在执行离开with代码块时被调用。
as指定符是可选的。如果你用 as 提供了一个 target_var，那么在上下文管理对象上调用 .__enter__() 的返回值将被绑定到该变量上。

# 使用with打开文件
```
with open("hello.txt", mode="w") as file:
    file.write("Hello, World!")
```

当你运行这个 with 语句时，open() 返回一个 io.TextIOBase 对象。这个对象也是一个上下文管理器，所以 with 语句调用 .__enter__() 并将其返回值分配给 file。然后你可以在 with 代码块中操作该文件。当代码块结束时，.__exit__() 会自动被调用，并为你关闭文件，即使在 with 代码块中引发了一个异常。

这个 with 结构比它的 try ... finally 更短，但它也不太通用，正如你已经看到的。你只能对支持上下文管理协议的对象使用with语句，而try ... finally允许你对任意对象执行清理操作，而不需要支持上下文管理协议。