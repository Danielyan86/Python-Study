# 概念

与其久经考验的表亲--多处理和线程--相比，异步 IO 的知名度要低一些。本节将让你更全面地了解什么是异步 IO，以及它是如何融入周围环境的。
Coroutines 是计算机程序组件，它概括了非抢占式多任务的子程序，允许在某些位置暂停和恢复执行的多个入口点。Coroutines 非常适用于实现熟悉的程序组件，如合作任务、异常、事件循环、迭代器、无限列表和管道。

## 异步 IO 法适合在哪里使用？

并发和并行是很广泛的主题，不容易涉足。虽然本文侧重于异步 IO 及其在 Python 中的实现，但还是值得花点时间将异步 IO 与它的同类产品进行比较，以便了解异步 IO 如何融入更大的、有时令人头晕的难题中。

- 并行性包括在同一时间执行多个操作。多处理是实现并行的一种手段，它需要将任务分散到计算机的中央处理单元（CPU，或核心）。多处理非常适合于由 CPU 约束的任务：严格约束的循环和数学计算通常属于这一类。

- 并发是一个比平行性稍宽的术语。它表明，多个任务有能力以重叠的方式运行。(有一种说法是，并发性并不意味着并行性）。

- 线程是一种并发执行模型，多个线程轮流执行任务。一个进程可以包含多个线程。由于它的 GIL，Python 与线程有着复杂的关系，但这已经超出了本文的范围。

关于线程，重要的是要知道它更适合于 IO 绑定的任务。与 CPU 绑定的任务的特点是计算机的核心从开始到结束不断地努力工作，而与 IO 绑定的工作则是以大量等待输入/输出完成为主导。

概括上述内容，并发性包括多处理（适合 CPU 绑定的任务）和线程（适合 IO 绑定的任务）。多处理是并行的一种形式，而并行是并发的一种特殊类型（子集）。Python 标准库通过它的多处理、线程和 concurrent.futures
包为这两种类型提供了长期的支持。

现在是时候给这个组合带来一个新成员了。在过去的几年里，一种独立的设计已经被更全面地内置到 CPython 中：异步 IO，通过标准库的 asyncio 包和新的 async 和 await 语言关键字来实现。要清楚的是，async
IO 并不是一个新发明的概念，它已经存在或正在被构建到其他语言和运行时环境中，比如 Go、C#或 Scala。

asyncio 包被 Python 文档标榜为编写并发代码的库。然而，async IO 并不是线程，也不是多进程。它不是建立在这两者之上的。

事实上，async IO 是一种单线程、单进程的设计：它使用合作式多任务，这个术语你将在本教程的最后充实它。有人说，尽管在单个进程中使用单线程，但 async
IO 给人一种并发的感觉。Coroutines（异步 IO 的一个核心特征）可以被安排为并发，但它们本身并不是并发的。

重申一下，async IO 是一种并发编程的风格，但它不是并行主义。它与线程的关系比与多处理的关系更密切，但与这两者都有很大的区别，是并发性技巧袋中的一个独立成员。

## 异步是什么意思？

这不是一个严格的定义，但对于我们这里的目的，有两个属性。

- 异步程序能够在等待最终结果时 "暂停"，并让其他程序在此期间运行。
- 异步代码，通过上述机制，促进了并发执行。换句话说，异步代码给人以并发的外观和感觉。 这里有一张图，把这一切放在一起。白色的术语代表概念，绿色的术语代表它们被实现或影响的方式。
  ![avatar](concept.png)

# 异步 IO

非同步 IO 起初可能看起来有悖常理，自相矛盾。促进并发代码的东西怎么会使用一个线程和一个 CPU 核心呢? Grinberg 在 2017 年 PyCon 演讲中的一个例子，它很好地解释了一切。

国际象棋大师 Judit Polgár 举办了一个国际象棋展览，她与多名业余棋手对弈。她有两种进行展示的方式：同步和异步。

## 同步版本

假设 24 个对手 朱迪在 5 秒内走完每一步棋 对手每走一步需要 55 秒 游戏平均 30 步对局（共 60 步）。 同步版本。朱迪特每次下一盘棋，决不是同时下两盘，直到游戏结束。每盘棋需要（55+5）_30==1800 秒，即 30 分钟。整个展览需要 24_
30==720 分钟，或 12 小时。

## 异步版本

异步版本。朱迪特从一个桌子移动到另一个桌子，在每个桌子上走一步。她离开桌子，让对手在等待时间内走下一步棋。在所有 24 个游戏上走一步，朱迪需要 24*5==120 秒，即 2 分钟。整个展览现在被削减到 120*30==3600 秒，或仅仅 1 小时。(
资料来源)

只有一个朱迪特-波尔加尔，她只有两只手，每次只自己走一步。但异步游戏将展览时间从 12 小时减少到 1 小时。因此，合作式多任务是一种花哨的说法，即程序的事件循环（后面会详细介绍）与多个任务进行沟通，让每个任务在最佳时间轮流运行。

异步输入法将函数阻塞的漫长等待期拿出来，让其他函数在这段停顿时间内运行。(一个阻塞的函数从它开始运行到它返回时，有效地禁止了其他函数的运行。)

# 异步 IO 并不简单

我听人说过，"能用异步 IO 就用异步 IO，必须用线程时就用线程"。事实是，构建持久的多线程代码是很难的，而且容易出错。异步 IO 避免了一些潜在的障碍，否则你可能会在线程设计中遇到这些障碍。

但这并不是说 Python 中的异步 IO 很容易。请注意：当你在表层以下冒险时，异步编程也是很困难的!
Python 的异步模型是围绕着回调、事件、传输、协议和未来等概念建立的--仅仅是这些术语就会让人感到害怕。事实上，它的 API 一直在不断地变化，这也让它变得更加容易。

幸运的是，asyncio 已经成熟到一个地步，它的大部分功能都不再是临时性的，同时它的文档也得到了巨大的修改，一些关于这个主题的高质量资源也开始出现了。

# async/await 语法和原生协程

> 小心你在互联网上读到的东西。从 Python 3.4 到 Python 3.7，Python 的异步 IO API 发展得很快。一些旧的模式不再使用，一些起初不允许的东西现在通过新的引入被允许了。

非同步 IO 的核心是
coroutines。coroutine 是 Python 生成器函数的一个专门版本。让我们从一个基线定义开始，然后随着你在这里的进展而建立：一个 coroutine 是一个可以在到达返回之前暂停执行的函数，它可以间接地将控制权传递给另一个 coroutine 一段时间。

稍后，你将深入研究传统的生成器究竟是如何被重新利用到 coroutine 中的。现在，了解 coroutine 如何工作的最简单方法是开始制作一些。

让我们采取身临其境的方式，写一些异步 IO 代码。这个简短的程序是异步 IO 的 Hello World，但对说明其核心功能有很大帮助。

> countasy.py

# 异步 IO 的规则

在这一点上，对 async、await 以及它们所创建的 coroutine 函数进行更正式的定义是必要的。这一节有点密集，但掌握 async/await 是很重要的，所以如果你需要的话，请回来看看。

语法 `async def` 介绍了一个本地的 coroutine 或异步生成器。async with 和 async for 表达式也是有效的，你将在后面看到它们。

关键字 await 将函数控制权传回给事件循环。(它暂停周围 coroutine 的执行。) 如果 Python 在 g() 的范围内遇到一个 await f() 表达式，这就是 await 告诉事件循环的方式："暂停 g()
的执行，直到我正在等待的东西--f() 的结果--被返回。同时，去让别的东西运行"。

在代码中，第二个要点看起来大致是这样的。

```python
async def g():
    # Pause here and come back to g() when f() is ready
    r = await f()
    return r
```

还有一套严格的规则，围绕着何时和如何使用 async/await。无论你是在学习语法还是已经接触过使用 async/await，这些规则都很方便。

- 你用 async def 引入的一个函数是一个 coroutine。它可以使用 await、return 或 yield，但所有这些都是可选的。声明 async def noop(): pass 是有效的。

  - 使用 await 和/或 return 创建一个 coroutine 函数。要调用一个循环函数，你必须等待它以获得其结果。

  - 在异步 def 块中使用 yield 是不太常见的（最近才合法）。这将创建一个异步生成器，你用 async for 来迭代它。暂时忘掉异步生成器，集中精力学习 coroutine 函数的语法，它使用 await 和/或 return。

  - 任何用 async def 定义的东西都不能使用 yield from，这将引发 SyntaxError。

- 就像在 def 函数之外使用 yield 是一个语法错误一样，在 async def coroutine 之外使用 await 也是一个语法错误。你只能在 coroutine 的主体中使用 await。

```python

async def f(x):
    y = await z(x)  # OK - `await` and `return` allowed in coroutines
    return y


async def g(x):
    yield x  # OK - this is an async generator


async def m(x):
    yield from gen(x)  # No - SyntaxError


def m(x):
    y = await z(x)  # Still no - SyntaxError (no `async def` here)
    return y
```

最后，当你使用 await f() 时，要求 f() 是一个可等待的对象。嗯，这不是很有帮助，不是吗？现在，只要知道一个可等待的对象是

- (1) 另一个 coroutine
- (2) 一个定义了返回一个迭代器的 `.__await__()` 方法的对象。如果你正在写一个程序，对于绝大多数的目的，你应该只需要担心情况 1。

这给我们带来了一个你可能会看到的技术上的区别：将一个函数标记为 coroutine 的老方法是用@asyncio.coroutine 来装饰一个正常的 def 函数。其结果是一个基于生成器的 coroutine。自从 async/await 语法在
Python 3.5 中出现后，这种结构已经过时了。

这两个 coroutine 基本上是等价的 (都是可等待的)，但第一个是基于生成器的，而第二个是原生 coroutine。

```python

import asyncio


@asyncio.coroutine
def py34_coro():
    """Generator-based coroutine, older syntax"""
    yield from stuff()


async def py35_coro():
    """Native coroutine, modern syntax"""
    await stuff()
```

## 执行异步（协程）函数

example

```python
import asyncio


async def main():
    await asyncio.sleep(1)
    print('hello')


asyncio.run(main())
```

下面是一个关于异步 IO 如何减少等待时间的例子：给定一个循环程序 makerandom()，它不断产生范围为[0, 10]
的随机整数，直到其中一个超过阈值，你想让这个循环程序的多个调用不需要等待对方连续完成。你大体上可以沿用上面两个脚本的模式，只是稍作改动。

> randy.py

# 异步 IO 设计模式

异步 IO 有它自己的一套可能的脚本设计，你将在这一节中得到介绍。

## 链式循环程序

Coroutines 的一个关键特征是它们可以被串联起来。(记住，一个 coroutine 对象是可等待的，所以另一个 coroutine 对象可以等待它）。 这允许你将程序分解成更小的、可管理的、可回收的 coroutine 程序。

## 使用队列

使用队列 asyncio 包提供了队列类，其设计类似于队列模块的类。在我们到目前为止的例子中，我们还没有真正需要一个队列结构。在 chained.py 中，每个任务（future）都是由一组 coroutines 组成的，这些
coroutines 明确地互相等待，并在每条链上传递一个输入。

有一个替代的结构，也可以与异步 IO 一起工作：一些生产者，它们之间没有关联，向一个队列添加项目。每个生产者可以在交错的、随机的、未宣布的时间向队列中添加多个项目。一组消费者从队列中提取物品，因为它们出现了，贪婪地，不等待任何其他信号。

在这种设计中，没有任何一个消费者与生产者之间的连锁关系。消费者不知道生产者的数量，甚至不会提前知道将被添加到队列中的项目的累积数量。

单个生产者或消费者分别需要花费不同的时间来放置和提取队列中的项目。队列作为一个吞吐量，可以与生产者和消费者沟通，而不需要他们直接对话。

注意：虽然由于 queue.Queue()的线程安全，队列经常被用于线程程序中，但当涉及到异步 IO 时，你不需要需要关注线程安全问题.

队列的一个用例（如这里的情况）是队列作为生产者和消费者的发送器，而这些生产者和消费者并不是直接连锁或相互关联的。

这个程序的同步版本看起来非常糟糕：一组阻塞的生产者连续向队列中添加项目，一次一个生产者。只有在所有生产者都完成后，才能由一个消费者逐项处理队列。这种设计有很大的延迟性。项目可能会在队列中闲置，而不是立即被拾起和处理。

下面是一个异步的版本，

> asyncq.py。
> 这个工作流程的挑战在于，需要有一个信号给消费者，说明生产已经完成。否则，await q.get()将无限期地挂起，因为队列将被完全处理，但消费者不会有任何生产完成的想法。

理清了 main()的思路：关键是等待 q.join()，它一直阻塞到队列中的所有项目都被接收和处理，然后取消消费者任务，否则这些任务会挂起，无休止地等待更多队列项目出现。）

# 什么时候以及为什么异步 IO 是正确的选择？

异步 IO 与多处理的争斗其实根本不是什么争斗。事实上，它们可以协同使用。

如果所有的函数都使用阻塞调用，简单地把 async 放在每个函数前是一个坏主意。(这实际上会拖慢你的代码。）但如前所述，在有些地方，async IO 和多处理可以和谐相处。

异步 IO 和线程之间的较量更直接一些。我在介绍中提到，"线程很困难"。完整的故事是，即使在线程看起来很容易实现的情况下，由于竞赛条件和内存使用等原因，它仍然可能导致臭名昭著的无法追踪的错误。

线程的扩展也往往不如异步 IO 那么优雅，因为线程是一种可用性有限的系统资源。创建成千上万的线程在很多机器上都会失败，我不建议一开始就去尝试。创建成千上万的异步 IO 任务是完全可行的。

当你有多个 IO 绑定的任务时，异步 IO 会大放异彩，否则这些任务会被阻塞的 IO 绑定的等待时间所支配，例如。

- 网络 IO，无论你的程序是服务器还是客户端

- 无服务器设计，如点对点的多用户网络，如小组聊天室

# 参考文档

- https://realpython.com/async-io-python/
